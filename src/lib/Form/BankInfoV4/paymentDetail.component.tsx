/************************************************************
 * Copyright (c) 2024 Orolabs.ai to Present
 * Author: Noopur Landge
 ************************************************************/

import React, { Fragment, useEffect, useMemo, useRef, useState } from 'react'
import { Grid, Tooltip } from '@mui/material'
import { AlertCircle, Check, ChevronDown, ChevronUp, Edit3, Info, Trash } from 'react-feather'
import classnames from 'classnames'

import { CountryBankKey, Field, emptyEcncryptedData } from '../types'
import { BankDetails, getAccountTypeDisplayName, getPaymentModeOptions } from './types'
import { Option } from '../../Types/input'
import { Address, Attachment, BankKey, EncryptedData, IntermediaryBankInfo, OroMasterDataType } from '../../Types/common'
import {
  COL1, COL2, COL3, COL4, areArraysSame, areObjectsSame, getEmptyAddress, getFormFieldsMap,
  isAddressInvalid, isEmpty, isFieldDisabled, isFieldOmitted, isFieldRequired, mapBankAddress, mapStringToOption, mergeOptions
} from '../util'
import { debounce, getMaskedString } from '../../util'
import { GoogleMultilinePlaceSearch, Radio, TextBox, ToggleSwitch, TypeAhead, imageFileAcceptType, pdfFileAcceptType } from '../../Inputs'
import { NAMESPACES_ENUM, getI18Text, useTranslationHook } from '../../i18n'
import { BankDocumentType, BankInfo, PaymentDetail, PaymentDetailFormProps, PaymentMode, PaymentModeType } from '../BankInfoV3/types'
import Separator from '../../controls/atoms/Separator'
import { EncryptedDataBox } from '../../Inputs/text.component'
import { getSignedUser, isValidSession } from '../../SigninService/signin.service'
import {
  canShowAccountHolderAddress, canShowAccountHolderName, canShowAccountNumber, canShowAccountType,
  canShowBankCode, canShowBankName, canShowCheckAddress, canShowInternationalCode, canShowIbanToggle,
  canShowPaymentAddress, canShowSwiftCode, canRespectSwiftCodeConfig, canShowBankDocuments, canDirectDebitMessage, canShowIntermediaryBank,
  SWIFT_CODE, BANK_DOUCUMENT, REMITTANCE_ADDR, PAYMENT_MODES, COMPANY_ENTITIES,
  BANK_ADDRESS, BANK_NAME, ACCOUNT_HOLDER, ACCOUNT_HOLDER_ADDR, ACCOUNT_NUMBER,
  ACCOUNT_TYPE, ATTACHMENT, BANK_CODE, BANK_CODE_ERROR,
  CHECK_DELIVERY_ADDRESS, DOCUMENT_TYPE, ENCRYPTED_BANK_CODE, ENCRYPTED_INTERNATIONAL_CODE,
  INTERNATIONAL_CODE, INTERNATIONAL_CODE_ERROR, INTERNATIONAL_KEY, INTREMEDIARY_ADDRESS, INTREMEDIARY_CODE,
  INTREMEDIARY_CODE_ERROR, INTREMEDIARY_KEY, INTREMEDIARY_NAME, INTREMEDIARY_REQUIRED, IS_DEMESTIC,
  IS_IBAN_AVAILABLE, IS_INTERNATIONAL, KEY, NO_DETAILS_NEEDED, PAYMENT_ADDRESS, SWIFT_CODE_ERROR,
  mapToInternalModeType, mapToCountrySpecificModeType, SELECTED, BANK_KEYS, areAccountNamesSame
} from './utils'

import styles from '../BankInfoV3/style.module.scss'
import v4Styles from './styles.module.scss'
import { AttachmentControlNew, OroButton } from '../../controls'
import { PaymentModeCard } from './paymentModeCard.component'
import { configurableFields } from './AccountDetails'
import { PaymentDetailBox } from './SupplierPaymentDetails-readOnly.component'
import { Trans } from 'react-i18next'

export function PaymentDetailForm(props: PaymentDetailFormProps) {
  const BankProofDisplayNames = {
    bankletter: getI18Text('--bankletter--'),
    estatement: getI18Text('--estatement--'),
    letterhead: getI18Text('--letterhead--'),
    invoicewithbank: getI18Text('--invoicewithbank--'),
    voidcheck: getI18Text('--voidcheck--'),
    quotation: getI18Text('--quotation--'),
    contract: getI18Text('--contract--'),
    proformainvoice: getI18Text('--proformainvoice--'),
    blankinvoice: getI18Text('--blankinvoice--'),
    debitform: getI18Text('--debitform--'),
    banklettermex: getI18Text('--banklettermex--'),
    estatementmex: getI18Text('--estatementmex--'),
    iban: getI18Text('--iban--'),
    rib: getI18Text('--rib--'),
    bankpermitchina: getI18Text('--bankpermitchina--'),
    supplierbankletterchina: getI18Text('--supplierbankletterchina--'),
    bankconfirmation: getI18Text('--bankconfirmation--'),
    bankpassbook: getI18Text('--bankpassbook--')
  }
  const PaymentModeOptions = getPaymentModeOptions()

  // State
  const [selected, setSelected] = useState<boolean>(false)

  const [bankCountry, setBankCountry] = useState<Option>()
  const [bankAddress, setBankAddress] = useState<Address>(getEmptyAddress())
  const [paymentModes, setPaymentModes] = useState<PaymentMode[]>([])
  const [companyEntities, setCompanyEntities] = useState<Option[]>([])

  const [bankName, setBankName] = useState<string>()
  const [bankNameAutoGenerated, setBankNameAutoGenerated] = useState<boolean>(false)
  const [accountHolder, setAccountHolder] = useState<string>()
  const [accountHolderAddress, setAccountHolderAddress] = useState<Address>(getEmptyAddress())
  const [paymentAddress, setPaymentAddress] = useState<EncryptedData>(emptyEcncryptedData)
  const [accountTypeOptions, setAccountTypeOptions] = useState<Option[]>([])
  const [accountTypeOption, setAccountTypeOption] = useState<Option>()
  const [accountNumber, setAccountNumber] = useState<EncryptedData>(emptyEcncryptedData)
  const [accountNumberAutoGenerated, setAccountNumberAutoGenerated] = useState<boolean>(false)

  const [keyOptions, setKeyOptions] = useState<Option[]>([])
  const [keyOption, setKeyOption] = useState<Option>()
  const [bankCode, setBankCode] = useState<string>('')
  const [bankCodeEncrypted, setBankCodeEncrypted] = useState<boolean>(false)
  const [encryptedBankCode, setEncryptedBankCode] = useState<EncryptedData>(emptyEcncryptedData)
  const [bankCodeAutoGenerated, setBankCodeAutoGenerated] = useState<boolean>(false)
  const [bankCodeError, setBankCodeError] = useState<boolean>(false)

  const [internationalCode, setInternationalCode] = useState<string>('')
  const [internationalCodeEncrypted, setInternationalCodeEncrypted] = useState<boolean>(true) // It stores IBAN; always encrypted
  const [encryptedInternationalBankCode, setEncryptedInternationalBankCode] = useState<EncryptedData>(emptyEcncryptedData)
  const [internationalCodeError, setInternationalCodeError] = useState<boolean>(false)

  const [swiftCode, setSwiftCode] = useState<string>('')
  const [swiftCodeAutoGenerated, setSwiftCodeAutoGenerated] = useState<boolean>(false)
  const [swiftCodeError, setSwiftCodeError] = useState<boolean>(false)

  const [checkDeliveryAddress, setCheckDeliveryAddress] = useState<Address>(getEmptyAddress())

  const [isIbanAvailable, setIsIbanAvailable] = useState<boolean | undefined>()

  const [documentType, setDocumentType] = useState<Option>()
  const [attachment, setAttachment] = useState<Attachment>()

  const [intermediaryBankRequired, setIntermediaryBankRequired] = useState<boolean>(false)
  const [intermediaryBankName, setIntermediaryBankName] = useState<string>('')
  const [intermediaryBankAddress, setIntermediaryBankAddress] = useState<Address>(getEmptyAddress())
  const [intermediaryKey, setIntermediaryKey] = useState<BankKey>('')
  const [intermediaryBankCode, setIntermediaryBankCode] = useState<string>('')
  const [intermediaryCodeError, setIntermediaryCodeError] = useState<boolean>(false)

  const [bankKeys, setBankKeys] = useState<CountryBankKey>()

  const [paymentModeOptions, setPaymentModeOptions] = useState<{ [country: string]: PaymentModeType[] }>({})
  const [documentTypeOptions, setDocumentTypeOptions] = useState<Option[]>([])

  const [forceValidate, setForceValidate] = useState<boolean>(false)
  const [fieldMap, setFieldMap] = useState<{ [key: string]: Field }>({})
  const fieldRefMap = useRef<{ [key: string]: HTMLDivElement }>({})
  function storeRef(fieldName: string, node: HTMLDivElement) {
    fieldRefMap.current[fieldName] = node
  }
  const [expanded, setExpanded] = useState<boolean>(false)
  const { t } = useTranslationHook([NAMESPACES_ENUM.BANKINFO])
  const IS_IBAN_AVAILABLE_OPTIONS: Option[] = [
    { id: 'true', path: 'true', displayName: t('--iHaveIban--'), selectable: true },
    { id: 'false', path: 'false', displayName: t('--noIban--'), selectable: true }
  ]

  function triggerValidations() {
    setForceValidate(true)
    setTimeout(() => {
      setForceValidate(false)
    }, 1000)
  }

  useEffect(() => {
    triggerValidations()
  }, [bankCodeError, internationalCodeError, swiftCodeError, intermediaryCodeError]) // bankCode2Error

  // Sync state from parent
  useEffect(() => {
    if (props.data) {
      setSelected(props.data?.selectedExistingBankInfo)

      if (props.data.bankInformation?.bankAddress?.alpha2CountryCode) {
        setBankAddress(mapBankAddress(props.data.bankInformation?.bankAddress))
      }
      setCompanyEntities(props.data.companyEntities || [])

      setBankName(props.data.bankInformation?.bankName || '')
      setBankNameAutoGenerated(props.data.bankInformation?.bankNameAutoGenerated || false)
      setAccountHolder(props.data.bankInformation?.accountHolder || props.partnerName || '')
      setAccountHolderAddress(props.data.bankInformation?.accountHolderAddress || getEmptyAddress())
      setPaymentAddress(props.data.bankInformation?.paymentAddress || emptyEcncryptedData)
      setAccountTypeOption(props.data.bankInformation?.accountType ? mapStringToOption(props.data.bankInformation.accountType) : undefined)
      setAccountNumber(props.data.bankInformation?.accountNumber || emptyEcncryptedData)
      setAccountNumberAutoGenerated(props.data.bankInformation?.accountNumberAutoGenerated || false)

      setKeyOption(props.data.bankInformation?.key ? mapStringToOption(props.data.bankInformation.key) : undefined)
      setBankCode(props.data.bankInformation?.bankCode || '')
      setEncryptedBankCode(props.data.bankInformation?.encryptedBankCode || emptyEcncryptedData)
      if (props.data.bankInformation?.encryptedBankCode?.maskedValue) {
        setBankCodeEncrypted(true)
      }
      setBankCodeAutoGenerated(props.data.bankInformation?.bankCodeAutoGenerated)
      setBankCodeError(props.data.bankInformation?.bankCodeError)

      setInternationalCode(props.data.bankInformation?.internationalCode || '')
      if (props.data.bankInformation?.encryptedInternationalBankCode?.maskedValue || props.data.bankInformation?.encryptedInternationalBankCode?.unencryptedValue) {
        setInternationalCodeEncrypted(true)
        if (!props.data.bankInformation?.internationalCode) {
          setInternationalCode(props.data.bankInformation?.encryptedInternationalBankCode?.unencryptedValue)
        }
      }
      setEncryptedInternationalBankCode(props.data.bankInformation?.encryptedInternationalBankCode)
      setInternationalCodeError(props.data.bankInformation?.internationalCodeError)

      setSwiftCode(props.data?.bankInformation?.swiftCode || '')
      setSwiftCodeAutoGenerated(props.data.bankInformation?.swiftCodeAutoGenerated || false)
      setSwiftCodeError(props.data?.bankInformation?.swiftCodeError)

      setCheckDeliveryAddress(props.data.bankInformation?.checkDeliveryAddress || getEmptyAddress())

      setIsIbanAvailable(props.data?.bankInformation?.isIbanAvailable)

      setDocumentType(props.data.documentType ? mapStringToOption(props.data.documentType) : undefined)
      setAttachment(props.data.attachment)

      setIntermediaryBankRequired(props.data.intermediaryBankRequired || false)
      if (props.data.intermediaryBankInformation) {
        setIntermediaryBankName(props.data.intermediaryBankInformation.bankName)
        setIntermediaryBankAddress(props.data.intermediaryBankInformation.bankAddress)
        setIntermediaryKey(props.data.intermediaryBankInformation.key)
        setIntermediaryBankCode(props.data.intermediaryBankInformation.bankCode)
        setIntermediaryCodeError(props.data.intermediaryBankInformation.bankCodeError)
      }
    }
  }, [props.data])

  useEffect(() => {
    const country = mapBankAddress(props.data?.bankInformation?.bankAddress)?.alpha2CountryCode
    const matchingEntry = props.countryOptions?.find(entry => entry.path === country)
    if (!areObjectsSame(bankCountry, matchingEntry)) {
      setBankCountry(matchingEntry)
    }
  }, [props.data, props.countryOptions])

  useEffect(() => {
    if (props.fields) {
      setFieldMap(getFormFieldsMap(props.fields, configurableFields))
    }
  }, [props.fields])

  // Component functionality :-

  function getPaymentModes (): PaymentMode[] {
    return paymentModes.map(mode => {
      return {
        ...mode,
        type: mapToCountrySpecificModeType(mode.type, bankAddress?.alpha2CountryCode, mode.companyEntityCountry, props.paymentModeConfig)
      }
    })
  }

  function getFormData(): PaymentDetail {
    return {
      id: props.data?.id,
      companyEntities,
      paymentModes: getPaymentModes(),
      bankInformation: {
        bankAddress,
        bankName,
        bankNameAutoGenerated,
        accountHolder,
        accountHolderAddress,
        accountType: accountTypeOption?.path,
        accountNumber,
        accountNumberAutoGenerated,
        paymentAddress,
        key: keyOption ? keyOption.path as BankKey : '',
        bankCode: (!bankCodeEncrypted) ? bankCode : '',
        encryptedBankCode: (bankCodeEncrypted) ? encryptedBankCode : undefined,
        bankCodeAutoGenerated,
        bankCodeError,
        internationalKey: 'iban',
        internationalCode: (!internationalCodeEncrypted) ? internationalCode : '',
        encryptedInternationalBankCode: (internationalCodeEncrypted) ? encryptedInternationalBankCode : emptyEcncryptedData,
        internationalCodeError,
        swiftCode: swiftCode,
        swiftCodeAutoGenerated,
        swiftCodeError,
        checkDeliveryAddress,
        isIbanAvailable
      },
      intermediaryBankRequired,
      intermediaryBankInformation: (intermediaryBankRequired) ? {
        bankName: intermediaryBankName,
        bankAddress: intermediaryBankAddress,
        key: intermediaryKey,
        bankCode: intermediaryBankCode,
        bankCodeError: intermediaryCodeError
      } : null,
      documentType: (documentType?.path as BankDocumentType) || undefined,
      attachment,
      selectedExistingBankInfo: selected,
      bankKeys
    }
  }

  // Sync state to parent
  useEffect(() => {
    if (props.onReady) {
      props.onReady(getFormData)
    }
  }, [
    props.data?.id,
    companyEntities, paymentModes,
    bankAddress, bankName, accountHolder, accountHolderAddress, accountTypeOption, accountNumber, paymentAddress,
    keyOption, bankCode, bankCodeEncrypted, encryptedBankCode, bankCodeError,
    internationalCode, internationalCodeEncrypted, encryptedInternationalBankCode, internationalCodeError,
    checkDeliveryAddress, swiftCode, swiftCodeError,
    intermediaryBankRequired, intermediaryBankName, intermediaryBankAddress, intermediaryKey, intermediaryBankCode, intermediaryCodeError,
    documentType, attachment,
    isIbanAvailable, bankKeys, selected, bankCodeAutoGenerated, bankNameAutoGenerated, accountNumberAutoGenerated, swiftCodeAutoGenerated
  ])

  // generate applicable payment modes
  useEffect(() => {
    if (props.paymentModeConfig && (props.paymentModeConfig.length > 0) && bankCountry && (companyEntities.length > 0)) {
      // Available payment types
      const _paymentModeConfig: { [country: string]: { domestic: PaymentModeType[], international: PaymentModeType[] } } = {}
      if (props.paymentModeConfig) {
        props.paymentModeConfig.forEach(config => {
          const domesticModes = (config.domestic || []).map(mapToInternalModeType)
          const internationalModes = (config.international || []).map(mapToInternalModeType)

          _paymentModeConfig[config.alpha2Code] = {
            domestic: domesticModes,
            international: internationalModes,
          }
        })
      }

      // Update paymentModes
      const _paymentModeOptions: { [country: string]: PaymentModeType[] } = {}
      const _paymentModes: PaymentMode[] = []
      const parsedCountries = {}
      companyEntities.filter(entity => {
        return props.companyEntityOptions?.some(option => option.path === entity.path)
      }).forEach(entity => {
        const entityOption = props.companyEntityOptions?.find(option => option.path === entity.path)
        const entityCountry = entityOption.customData?.other?.countryCode
        const entityCurrency = entityOption.customData?.other?.currencyCode

        const configForEntity = _paymentModeConfig[entityCountry] || _paymentModeConfig['default'] || { domestic: [], international: [] }
        const isEntityDomestic = entityCountry === bankCountry.path
        const availableModeOptions = isEntityDomestic ? configForEntity.domestic : configForEntity.international
        _paymentModeOptions[entityCountry] = availableModeOptions

        const entityPaymentModeType = availableModeOptions[0]

        const existingCurrencySelection = props.data?.paymentModes?.find(mode => mode.companyEntityCountry === entityCountry)?.currencyCode
        const existingModeTypeSelection = props.data?.paymentModes?.find(mode => mode.companyEntityCountry === entityCountry)?.type
        const isexistingModeTypeSelectionAvailable = availableModeOptions.some(option => option === existingModeTypeSelection)
        const existingAdditionalCurrency = props.data?.paymentModes?.find(mode => mode.companyEntityCountry === entityCountry)?.additionalCurrencyRequested

        if (!parsedCountries[entityCountry]) {
          _paymentModes.push({
            companyEntityCountry: entityCountry,
            type: (isexistingModeTypeSelectionAvailable && existingModeTypeSelection && mapToInternalModeType(existingModeTypeSelection)) || entityPaymentModeType,
            currencyCode: existingCurrencySelection || props.partnerCurrency || entityCurrency,
            additionalCurrencyRequested: existingAdditionalCurrency || ''
          })
          parsedCountries[entityCountry] = true
        }
      })

      setPaymentModeOptions(_paymentModeOptions) // { 'US': ['check', 'wire', 'ach'], 'MX': ['wire', 'ach'] }
      setPaymentModes(_paymentModes)
      // handleFieldValueChange(PAYMENT_MODES, paymentModes, _paymentModes)
    } else {
      setPaymentModeOptions({})
      setPaymentModes([])
      // handleFieldValueChange(PAYMENT_MODES, paymentModes, [])
    }
  }, [props.data, props.paymentModeConfig, props.partnerCurrency, bankCountry, companyEntities])

  // Update key options
  useEffect(() => {
    if (bankCountry?.path && props.getCountryBankKeys) {
      props.getCountryBankKeys(bankCountry?.path)
        .then(res => {
          setBankKeys(res)

          setAccountTypeOptions(res.accountTypes?.map(type => {
            return {
              id: type,
              path: type,
              displayName: getAccountTypeDisplayName(type),
              selectable: true
            }
          }) || [])

          if (res.domesticList && res.domesticList.length === 1) {
            const key = res.domesticList[0]
            setKeyOption({
              id: key,
              path: key,
              displayName: props.bankKeys?.find(enumVal => enumVal.code === key)?.name || key || t("Bank code"),
              selectable: true
            })
          }
          setKeyOptions(res.domesticList?.map(key => {
            return {
              id: key,
              path: key,
              displayName: props.bankKeys?.find(enumVal => enumVal.code === key)?.name || key || t("Bank code"),
              selectable: true
            }
          }) || [])
        })
        .catch(err => {
          console.warn('Error fetching bank keys. ', err)
        })
    }
  }, [bankCountry])

  // Update intermediary bank key
  useEffect(() => {
    if (intermediaryBankAddress?.alpha2CountryCode && props.getCountryBankKeys) {
      props.getCountryBankKeys(intermediaryBankAddress?.alpha2CountryCode)
        .then(res => {
          setIntermediaryKey(res.domestic)
        })
        .catch(err => {
          console.warn('Error fetching intermediary bank key. ', err)
        })
    }
  }, [intermediaryBankAddress])

  // update bank proof options
  useEffect(() => {
    let _docTypeOptions: Option[] = []
    if (isValidSession() && (getSignedUser()?.tenantId === 'ping_identity' || getSignedUser()?.tenantId === 'ping_identity_sandbox')) {
      const defaultDocumentOption = {
        id: 'bankletter',
        path: 'bankletter',
        displayName: BankProofDisplayNames.bankletter,
        selectable: true
      }
      _docTypeOptions = [defaultDocumentOption]
    } else if (props.bankProofConfig && (props.bankProofConfig.length > 0) && bankCountry) {
      const applicableDocuments = props.bankProofConfig.find(config => config.alpha2Code === bankCountry?.path)?.documents || []
      _docTypeOptions = applicableDocuments.map(doc => {
        return {
          id: doc as string,
          path: doc as string,
          displayName: BankProofDisplayNames[doc],
          selectable: true
        }
      })
    }
    setDocumentTypeOptions(_docTypeOptions)

    if (_docTypeOptions.length === 1) {
      setDocumentType(_docTypeOptions[0])
    }
  }, [props.bankProofConfig, bankCountry])

  function dispatchValidateBankInfo(bankInfo: BankInfo | IntermediaryBankInfo, validateInternational: boolean, callback: Function) {
    if (props.validateBankInfo) {
      props.validateBankInfo(bankInfo, validateInternational)
        .then(isValid => {
          callback(null, isValid)
        })
        .catch(err => {
          callback(err)
        })
    }
  }
  // 'useMemo' memoizes the debounced handler, but also calls debounce() only during initial rendering of the component
  const debouncedValidateBankInfo = useMemo(() => debounce(dispatchValidateBankInfo, 1500), [])

  // Validate bank codes
  useEffect(() => {
    if (props.validateBankInfo) {
      debouncedValidateBankInfo(getFormData().bankInformation, false, function (err, res?) {
        if (err) {
          console.warn('Error validating domestic bank info. ', err)
          return
        }
        setBankCodeError(!res)
      })
    }
  }, [bankCode, encryptedBankCode])
  useEffect(() => {
    if (props.validateBankInfo) {
      debouncedValidateBankInfo(getFormData().bankInformation, true, function (err, res?) {
        if (err) {
          console.warn('Error validating international bank info. ', err)
          return
        }
        setInternationalCodeError(!res)
      })
    }
  }, [internationalCode, encryptedInternationalBankCode])
  useEffect(() => {
    if (props.validateBankInfo) {
      const bankInfo: BankInfo = getFormData().bankInformation || {}
      const bankInformationCopy: BankInfo = {
        ...bankInfo,
        internationalKey: 'swift',
        internationalCode: bankInfo.swiftCode,
        encryptedInternationalBankCode: undefined
      }
      debouncedValidateBankInfo(bankInformationCopy, true, function (err, res?) {
        if (err) {
          console.warn('Error validating swift code info. ', err)
          return
        }
        setSwiftCodeError(!res)
      })
    }
  }, [swiftCode])
  useEffect(() => {
    if (props.validateBankInfo) {
      debouncedValidateBankInfo(getFormData().intermediaryBankInformation, false, function (err, res?) {
        if (err) {
          console.warn('Error validating intermediary bank info. ', err)
          return
        }
        setIntermediaryCodeError(!res)
      })
    }
  }, [intermediaryBankCode])

  function getBankDetails(code: string, key: BankKey, bankCountryCode: string) {
    props.getBankDetails(code, key, bankCountryCode)
      .then((res: BankDetails[]) => {
        if (res && res.length > 0) {
          const bankDetail = res[0]
          if (
            bankDetail?.code && (!bankCode || bankCodeAutoGenerated)
            // && canShowBankCode({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys })
          ) {
            setBankCode(bankDetail.code)
            setBankCodeAutoGenerated(true)
          }
          if (
            bankDetail?.name && (!bankName || bankNameAutoGenerated)
            // && canShowBankName({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys })
          ) {
            setBankName(bankDetail.name)
            setBankNameAutoGenerated(true)
          }
          if (
            bankDetail?.accountNumber && (!(accountNumber?.maskedValue || accountNumber?.unencryptedValue) || accountNumberAutoGenerated)
            // && canShowAccountNumber({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys })
          ) {
            setAccountNumber({ ...emptyEcncryptedData, unencryptedValue: bankDetail.accountNumber, maskedValue: '' })
            setAccountNumberAutoGenerated(true)
          }
          if (
            bankDetail?.swift && (!swiftCode || swiftCodeAutoGenerated)
            // && (canShowSwiftCode({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) ||
            //     (canRespectSwiftCodeConfig({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) && !isFieldOmitted(fieldMap, SWIFT_CODE)))
          ) {
            setSwiftCode(bankDetail.swift)
            setSwiftCodeAutoGenerated(true)
          }
        }
      })
      .catch(err => {
        console.log('getBankDetails: Could not fetch bank details: ', err)
      })
  }
  // 'useMemo' memoizes the debounced handler, but also calls debounce() only during initial rendering of the component
  const debouncedGetBankDetails = useMemo(
    () => debounce(getBankDetails),
    [
      bankCode, encryptedBankCode, bankCodeAutoGenerated, bankName, bankNameAutoGenerated, accountNumber, accountNumberAutoGenerated, swiftCode, swiftCodeAutoGenerated,
      paymentModes, bankAddress, isIbanAvailable, bankKeys
    ]
  )

  useEffect(() => {
    if (bankCode && keyOption?.path && bankCountry?.path) {
      debouncedGetBankDetails(bankCode, keyOption.path as BankKey, bankCountry.path)
    }
  }, [bankCode, keyOption, bankCountry])
  useEffect(() => {
    if (encryptedInternationalBankCode?.unencryptedValue && bankCountry?.path) {
      debouncedGetBankDetails(encryptedInternationalBankCode?.unencryptedValue, 'iban', bankCountry.path)
    }
  }, [encryptedInternationalBankCode, bankCountry])

  function getFormDataWithUpdatedValue(fieldName: string, newValue: string | Option | Option[] | Address | EncryptedData | boolean | PaymentMode[] | File | CountryBankKey): PaymentDetail {
    const formData = JSON.parse(JSON.stringify(getFormData())) as PaymentDetail

    switch (fieldName) {
      case COMPANY_ENTITIES:
        formData.companyEntities = newValue as Option[]
        break
      case BANK_ADDRESS:
        formData.bankInformation.bankAddress = newValue as Address
        break
      case PAYMENT_MODES:
        formData.paymentModes = newValue as PaymentMode[]
        break
      case BANK_NAME:
        formData.bankInformation.bankName = newValue as string
        break
      case ACCOUNT_HOLDER:
        formData.bankInformation.accountHolder = newValue as string
        break
      case ACCOUNT_HOLDER_ADDR:
        formData.bankInformation.accountHolderAddress = newValue as Address
        break
      case ACCOUNT_TYPE:
        formData.bankInformation.accountType = (newValue as Option)?.path
        break
      case ACCOUNT_NUMBER:
        formData.bankInformation.accountNumber = newValue as EncryptedData
        break
      case PAYMENT_ADDRESS:
        formData.bankInformation.paymentAddress = newValue as EncryptedData
        break
      case KEY:
        formData.bankInformation.key = (newValue as Option)?.path as BankKey
        break
      case BANK_CODE:
        formData.bankInformation.bankCode = newValue as string
        break
      case ENCRYPTED_BANK_CODE:
        formData.bankInformation.encryptedBankCode = newValue as EncryptedData
        break
      case BANK_CODE_ERROR:
        formData.bankInformation.bankCodeError = newValue as boolean
        break
      case INTERNATIONAL_KEY:
        formData.bankInformation.internationalKey = newValue as BankKey
        break
      case INTERNATIONAL_CODE:
        formData.bankInformation.internationalCode = newValue as string
        break
      case ENCRYPTED_INTERNATIONAL_CODE:
        const encryptData = newValue as EncryptedData
        formData.bankInformation.encryptedInternationalBankCode = newValue as EncryptedData
        formData.bankInformation.internationalCode = encryptData?.unencryptedValue
        break
      case INTERNATIONAL_CODE_ERROR:
        formData.bankInformation.internationalCodeError = newValue as boolean
        break
      case SWIFT_CODE:
        formData.bankInformation.swiftCode = newValue as string
        break
      case SWIFT_CODE_ERROR:
        formData.bankInformation.swiftCodeError = newValue as boolean
        break
      case CHECK_DELIVERY_ADDRESS:
        formData.bankInformation.checkDeliveryAddress = newValue as Address
        break
      case IS_IBAN_AVAILABLE:
        formData.bankInformation.isIbanAvailable = newValue as boolean
        break
      case DOCUMENT_TYPE:
        formData.documentType = (newValue as Option)?.path as BankDocumentType
        break
      case ATTACHMENT:
        formData.attachment = newValue as File
        break
      case INTREMEDIARY_REQUIRED:
        formData.intermediaryBankRequired = newValue as boolean
        break
      case INTREMEDIARY_NAME:
        if (formData.intermediaryBankInformation) {
          formData.intermediaryBankInformation.bankName = newValue as string
        }
        break
      case INTREMEDIARY_ADDRESS:
        if (formData.intermediaryBankInformation) {
          formData.intermediaryBankInformation.bankAddress = newValue as Address
        }
        break
      case INTREMEDIARY_KEY:
        formData.intermediaryBankInformation.key = newValue as BankKey
        break
      case INTREMEDIARY_CODE:
        if (formData.intermediaryBankInformation) {
          formData.intermediaryBankInformation.bankCode = newValue as string
        }
        break
      case INTREMEDIARY_CODE_ERROR:
        formData.intermediaryBankInformation.bankCodeError = newValue as boolean
        break
      case IS_DEMESTIC:
        formData.isDomestic = newValue as boolean
        break
      case IS_INTERNATIONAL:
        formData.isInternational = newValue as boolean
        break
      case SELECTED:
        formData.selectedExistingBankInfo = newValue as boolean
        break
      case BANK_KEYS:
        formData.bankKeys = newValue as CountryBankKey
        break
    }

    return formData
  }

  function validateAddressField(label: string, value: Address): string {
    if (!value) {
      return getI18Text("is required field", { label })
    } else if (isAddressInvalid(value)) {
      return getI18Text("is invalid", { label })
    } else {
      return ''
    }
  }
  function validateCheckAddress (value: Address): string {
    const invalidAddressError = validateAddressField(t("--checkDeliveryAddress--"), value)

    if (invalidAddressError) {
      return invalidAddressError
    }

    if (value?.alpha2CountryCode !== bankAddress?.alpha2CountryCode) {
      return t('--addressCannotBeDifferentFromBankCountry--')
    }

    return ''
  }

  function dispatchOnValueChange(fieldName: string, formData: PaymentDetail, isAttachment?: boolean) {
    if (props.onValueChange) {
      props.onValueChange(
        fieldName,
        formData,
        isAttachment
      )
    }
  }
  // 'useMemo' memoizes the debounced handler, but also calls debounce() only during initial rendering of the component
  const debouncedOnValueChange = useMemo(() => debounce(dispatchOnValueChange), [props.existing, selected])

  function handleFieldValueChange(
    fieldName: string,
    oldValue: string | Option | Option[] | Address | EncryptedData | boolean | PaymentMode[] | Attachment | CountryBankKey,
    newValue: string | Option | Option[] | Address | EncryptedData | boolean | PaymentMode[] | File | CountryBankKey,
    useDebounce?: boolean,
    isAttachment?: boolean
  ) {
    if (props.onValueChange) {
      if (typeof newValue === 'string' || typeof newValue === 'boolean') {
        if (oldValue !== newValue) {
          if (useDebounce) {
            debouncedOnValueChange(
              fieldName,
              getFormDataWithUpdatedValue(fieldName, newValue),
              isAttachment
            )
          } else {
            dispatchOnValueChange(
              fieldName,
              getFormDataWithUpdatedValue(fieldName, newValue),
              isAttachment
            )
          }
        }
      } else if (Array.isArray(oldValue) && Array.isArray(newValue)) {
        if (!areArraysSame(oldValue, newValue)) {
          if (useDebounce) {
            debouncedOnValueChange(
              fieldName,
              getFormDataWithUpdatedValue(fieldName, newValue),
              isAttachment
            )
          } else {
            dispatchOnValueChange(
              fieldName,
              getFormDataWithUpdatedValue(fieldName, newValue),
              isAttachment
            )
          }
        }
      } else if (!areObjectsSame(oldValue, newValue)) {
        if (useDebounce) {
          debouncedOnValueChange(
            fieldName,
            getFormDataWithUpdatedValue(fieldName, newValue),
            isAttachment
          )
        } else {
          dispatchOnValueChange(
            fieldName,
            getFormDataWithUpdatedValue(fieldName, newValue),
            isAttachment
          )
        }
      }
    }
  }

  function onBankCountryChanged(value?: Option) {
    if (value && value?.path !== bankCountry?.path) {
      setBankCountry(value)
      const address = { ...getEmptyAddress(), alpha2CountryCode: (value as Option)?.path }
      setBankAddress(address)
      handleFieldValueChange(BANK_ADDRESS, bankAddress, address)
    } else if (!value) {
      setBankCountry(null)
      const address = getEmptyAddress()
      setBankAddress(address)
      handleFieldValueChange(BANK_ADDRESS, bankAddress, address)
    }
  }

  function handleCurrencyRequest(currency?: string) {
    const _paymentModes = paymentModes.map(mode => {
      return {
        ...mode,
        additionalCurrencyRequested: currency
      }
    })
    setPaymentModes(_paymentModes)
    handleFieldValueChange(PAYMENT_MODES, paymentModes, _paymentModes)
  }

  function handleDeleteClick(e) {
    e.stopPropagation()
    if (props.onDeleteClick) {
      props.onDeleteClick()
    }
  }

  function onPlaceSelectParseAddress(place: google.maps.places.PlaceResult): Promise<Address> {
    if (props.onPlaceSelectParseAddress) {
      return props.onPlaceSelectParseAddress(place)
    } else {
      return Promise.reject()
    }
  }

  function loadFile(fieldName: string, type: string | undefined, fileName: string | undefined = 'document'): Promise<Blob> {
    if (props.loadDocument && fieldName) {
      return props.loadDocument(fieldName, type, fileName)
    } else {
      return Promise.reject()
    }
  }

  function getBankCurrency(): string | undefined {
    const bankCountryCode = bankCountry?.path || bankAddress?.alpha2CountryCode
    const bankCountryOption = props.countryOptions?.find(countryOption => countryOption.path === bankCountryCode)
    return bankCountryOption?.customData?.other?.currencyCode
  }

  function fetchChildren(masterDataType: OroMasterDataType, parent: string, childrenLevel: number): Promise<Option[]> {
    if (props.fetchChildren) {
      return props.fetchChildren(parent, childrenLevel, masterDataType)
    } else {
      return Promise.reject('fetchChildren API not available')
    }
  }

  function searchMasterdataOptions(keyword?: string, masterDataType?: OroMasterDataType): Promise<Option[]> {
    if (props.searchOptions) {
      return props.searchOptions(keyword, masterDataType)
    } else {
      return Promise.reject('searchOptions API not available')
    }
  }

  function toggleSelection() {
    const _selected = !selected

    if (_selected) {
      setCompanyEntities(mergeOptions(props.data.companyEntities || [], props.companyEntityOptions || []))
    } else {
      setCompanyEntities(props.data.companyEntities || [])
    }
    handleFieldValueChange(SELECTED, selected, _selected)

    setSelected(_selected)
  }

  function isAnyEntityMissingInExistinEntities() {
    const foundEntityWhichIsNotInExisting = props.companyEntityOptions?.some(entity => {
      const foundEntityInExisting = props.existingData?.companyEntities.some(existingEntity => {
        return existingEntity.path === entity.path
      })
      return !foundEntityInExisting
    })

    return foundEntityWhichIsNotInExisting
  }

  function isAnyModeIsMissingInExistingPaymentModes() {
    const foundModeWhichIsNotInExisting = paymentModes.some(paymentMode => {
      const foundModeInExisting = props.existingData?.paymentModes.some(existingPaymentMode => {
        return existingPaymentMode.companyEntityCountry === paymentMode.companyEntityCountry
      })
      return !foundModeInExisting
    })

    return foundModeWhichIsNotInExisting
  }

  const applicableFields = {
    [BANK_ADDRESS]: true,
    [COMPANY_ENTITIES]: !props.hideCompanyEntitySelector && bankCountry && props.companyEntityOptions && props.companyEntityOptions.length > 1,
    [PAYMENT_MODES]: bankCountry && companyEntities && companyEntities.length > 0,

    separator1: true,
    [IS_IBAN_AVAILABLE]: canShowIbanToggle({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [BANK_CODE]: canShowBankCode({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [INTERNATIONAL_CODE]: canShowInternationalCode({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [ACCOUNT_TYPE]: canShowAccountType({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [ACCOUNT_NUMBER]: canShowAccountNumber({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [PAYMENT_ADDRESS]: canShowPaymentAddress({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [ACCOUNT_HOLDER]: canShowAccountHolderName({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [ACCOUNT_HOLDER_ADDR]: !isFieldOmitted(fieldMap, REMITTANCE_ADDR) &&
      canShowAccountHolderAddress({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [BANK_NAME]: canShowBankName({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [CHECK_DELIVERY_ADDRESS]: canShowCheckAddress({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [SWIFT_CODE]: canShowSwiftCode({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) ||
      (canRespectSwiftCodeConfig({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) && !isFieldOmitted(fieldMap, SWIFT_CODE)),

    separator2: !isFieldOmitted(fieldMap, BANK_DOUCUMENT) &&
      canShowBankDocuments({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [DOCUMENT_TYPE]: !isFieldOmitted(fieldMap, BANK_DOUCUMENT) &&
      documentTypeOptions && (documentTypeOptions.length > 1) && canShowBankDocuments({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [ATTACHMENT]: !isFieldOmitted(fieldMap, BANK_DOUCUMENT) &&
      canShowBankDocuments({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),

    separator3: canShowIntermediaryBank({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [INTREMEDIARY_REQUIRED]: canShowIntermediaryBank({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }),
    [INTREMEDIARY_NAME]: canShowIntermediaryBank({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) && intermediaryBankRequired,
    [INTREMEDIARY_ADDRESS]: canShowIntermediaryBank({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) && intermediaryBankRequired,
    [INTREMEDIARY_CODE]: canShowIntermediaryBank({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) && intermediaryBankRequired,

    [NO_DETAILS_NEEDED]: canDirectDebitMessage({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys })
  }

  const _isAnyEntityMissingInExistinEntities = isAnyEntityMissingInExistinEntities()
  const _isAnyModeIsMissingInExistingPaymentModes = isAnyModeIsMissingInExistingPaymentModes()
  const existingData = {
    [BANK_ADDRESS]: true,
    [COMPANY_ENTITIES]: !_isAnyEntityMissingInExistinEntities,
    [PAYMENT_MODES]: !_isAnyModeIsMissingInExistingPaymentModes,

    separator1: props.existingData?.bankInformation?.accountNumber?.maskedValue || props.existingData?.bankInformation?.accountNumber?.unencryptedValue || props.existingData?.bankInformation?.checkDeliveryAddress?.alpha2CountryCode,
    // <---------
    [BANK_NAME]: props.existingData?.bankInformation?.bankName,
    [ACCOUNT_HOLDER]: props.existingData?.bankInformation?.accountHolder,

    [ACCOUNT_HOLDER_ADDR]: props.existingData?.bankInformation?.accountHolderAddress?.alpha2CountryCode,

    [ACCOUNT_TYPE]: props.existingData?.bankInformation?.accountType,
    [ACCOUNT_NUMBER]: props.existingData?.bankInformation?.accountNumber?.maskedValue || props.existingData?.bankInformation?.accountNumber?.unencryptedValue,
    [PAYMENT_ADDRESS]: props.existingData?.bankInformation?.paymentAddress,
    [BANK_CODE]: props.existingData?.bankInformation?.bankCode || props.existingData?.bankInformation?.encryptedBankCode?.maskedValue || props.existingData?.bankInformation?.encryptedBankCode?.unencryptedValue,
    [INTERNATIONAL_CODE]: props.existingData?.bankInformation?.internationalCode || props.existingData?.bankInformation?.encryptedInternationalBankCode?.maskedValue || props.existingData?.bankInformation?.encryptedInternationalBankCode?.unencryptedValue,
    [SWIFT_CODE]: props.existingData?.bankInformation?.swiftCode,
    [IS_IBAN_AVAILABLE]: props.existingData?.bankInformation?.internationalCode || props.existingData?.bankInformation?.encryptedInternationalBankCode?.maskedValue || props.existingData?.bankInformation?.encryptedInternationalBankCode?.unencryptedValue,
    [CHECK_DELIVERY_ADDRESS]: props.existingData?.bankInformation?.checkDeliveryAddress?.alpha2CountryCode,
    // --------->

    separator2: props.existingData?.attachment,
    // <---------
    [DOCUMENT_TYPE]: props.existingData?.documentType,
    [ATTACHMENT]: props.existingData?.attachment,
    // --------->

    separator3: props.existingData?.intermediaryBankInformation?.bankName && props.existingData?.intermediaryBankInformation?.bankAddress?.alpha2CountryCode && props.existingData?.intermediaryBankInformation?.bankCode,
    // <---------
    [INTREMEDIARY_REQUIRED]: props.existingData?.intermediaryBankInformation?.bankName && props.existingData?.intermediaryBankInformation?.bankAddress?.alpha2CountryCode && props.existingData?.intermediaryBankInformation?.bankCode,
    [INTREMEDIARY_NAME]: props.existingData?.intermediaryBankInformation?.bankName,
    [INTREMEDIARY_ADDRESS]: props.existingData?.intermediaryBankInformation?.bankAddress?.alpha2CountryCode,
    [INTREMEDIARY_CODE]: props.existingData?.intermediaryBankInformation?.bankCode
    // ---------> 
  }

  const cardDirectDebitMsg = (props.existing ? props.existingData?.paymentModes?.[0]?.type : paymentModes?.[0]?.type) === 'directDebit' &&
    (<div className={v4Styles.directDebitMsg}>
      <Trans t={t} i18nKey="--directDebitShallBeEnabled--">
        <span className={v4Styles.highlight}>{'Direct Debit'}</span>
        {' shall be enabled for payments'}
      </Trans>
    </div>)
  const cardBankName = props.existing
    ? (props.existingData?.bankInformation?.bankName || props.existingData?.bankInformation?.accountHolder)
    : (bankName || accountHolder)
  const cardIBAN = props.existing
    ? (props.existingData?.bankInformation?.encryptedInternationalBankCode?.maskedValue || getMaskedString(props.existingData?.bankInformation?.encryptedInternationalBankCode?.unencryptedValue))
    : (encryptedInternationalBankCode?.maskedValue || getMaskedString(encryptedInternationalBankCode?.unencryptedValue))
  const cardAccountNumber = props.existing
    ? (props.existingData?.bankInformation?.accountNumber?.maskedValue || getMaskedString(props.existingData?.bankInformation?.accountNumber?.unencryptedValue))
    : (accountNumber?.maskedValue || getMaskedString(accountNumber?.unencryptedValue))
  const cardPaymentAddress = props.existing
    ? (props.existingData?.bankInformation?.paymentAddress?.maskedValue || getMaskedString(props.existingData?.bankInformation?.paymentAddress?.unencryptedValue))
    : (paymentAddress?.maskedValue || getMaskedString(paymentAddress?.unencryptedValue))

  function getPaymentModeComponent() {
    return (<>
      {/* For existing, SHOW if existing paymentModes does not include any of evaluated paymentModes */}
      {/* Exclude existing modes while displaying */}
      {/* Exclude existing entities while displaying */}
      {applicableFields[PAYMENT_MODES] && (!props.existing || !existingData[PAYMENT_MODES]) &&
        <Grid item xs={COL4}>
          <div data-testid="payment-modes-field" ref={(node) => storeRef(PAYMENT_MODES, node)}>
            <PaymentModeCard
              data={paymentModes}
              bankCountry={bankCountry.displayName}
              bankCurrency={getBankCurrency()}
              disableBankCountry={true}
              canShowEntities={false} // applicableFields[COMPANY_ENTITIES]
              companyEntities={companyEntities}
              allowBankPayoutCurrencyRequest={props.allowBankPayoutCurrencyRequest}
              companyEntityOptions={props.companyEntityOptions}
              onRequestCurrency={handleCurrencyRequest}
              onEntityChange={setCompanyEntities}
            />
          </div>
        </Grid>}
    </>)
  }

  function getBankNameComponent() {
    return (<>
      {/* For existing, SHOW if bankName not available */}
      {applicableFields[BANK_NAME] && (!props.existing || !existingData[BANK_NAME]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="bank-name-field" ref={(node) => storeRef(BANK_NAME, node)}>
            <TextBox
              label={t("Bank name")}
              value={bankName}
              disabled={false}
              required={true}
              forceValidate={props.forceValidate || bankNameAutoGenerated}
              validator={(value) => isEmpty(value) ? getI18Text("is required field", { label: t("Bank name") }) : ''}
              onChange={value => { setBankName(value); setBankNameAutoGenerated(false); handleFieldValueChange(BANK_NAME, bankName, value) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getAccHolderComponent() {
    return (<>
      {/* For existing, SHOW if accountHolder not available */}
      {applicableFields[ACCOUNT_HOLDER] && (!props.existing || !existingData[ACCOUNT_HOLDER]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="account-holder-field" ref={(node) => storeRef(ACCOUNT_HOLDER, node)}>
            <TextBox
              label={t("--nameOnTheAccount--")}
              value={accountHolder}
              disabled={false}
              required={true}
              forceValidate={props.forceValidate}
              warning={accountHolder && (accountHolder !== props.partnerName)}
              validator={(value) => isEmpty(value)
                ? getI18Text("is required field", { label: t("--nameOnTheAccount--") })
                : (props.partnerName && !areAccountNamesSame(value, props.partnerName) ? t('--doesNotMatchCompanyName--', { company: props.partnerName }) : '')}
              onChange={value => { setAccountHolder(value); handleFieldValueChange(ACCOUNT_HOLDER, accountHolder, value) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getAccHolderAddressComponent() {
    return (<>
      {/* For existing, SHOW if accountHolderAddress not available */}
      {applicableFields[ACCOUNT_HOLDER_ADDR] && (!props.existing || !existingData[ACCOUNT_HOLDER_ADDR]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="account-holder-address-field" ref={(node) => storeRef(ACCOUNT_HOLDER_ADDR, node)}>
            <GoogleMultilinePlaceSearch
              id={`${ACCOUNT_HOLDER_ADDR}-${props.index}`}
              label={t("--addressOnAccount--")}
              value={accountHolderAddress}
              countryOptions={props.countryOptions}
              required={isFieldRequired(fieldMap, REMITTANCE_ADDR)}
              forceValidate={props.forceValidate}
              parseAddressToFill={(place) => onPlaceSelectParseAddress(place)}
              validator={(value) => isFieldRequired(fieldMap, REMITTANCE_ADDR) ? validateAddressField(t("--addressOnAccount--"), value) : ''}
              onChange={(value, countryChanged) => { setAccountHolderAddress(value); handleFieldValueChange(ACCOUNT_HOLDER_ADDR, accountHolderAddress, value) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getAccNumberComponent() {
    return (<>
      {/* For existing, SHOW if accountNumber not available */}
      {applicableFields[ACCOUNT_NUMBER] && (!props.existing || !existingData[ACCOUNT_NUMBER]) &&
        <>
          {(accountTypeOptions.length > 1)
            ? <>
              <Grid item md={COL1} xs={COL4}>
                <TypeAhead
                  label={t("--accountType--")}
                  value={accountTypeOption}
                  options={accountTypeOptions}
                  required={true}
                  forceValidate={props.forceValidate}
                  validator={(value) => (isEmpty(value)) ? getI18Text("is required field", { label: t("--accountType--") }) : ''}
                  onChange={value => { setAccountTypeOption(value); handleFieldValueChange(ACCOUNT_TYPE, keyOption, value) }}
                />
              </Grid>
              <Grid item md={COL2} xs={COL4}>
                <div data-testid="account-number-field" ref={(node) => storeRef(ACCOUNT_NUMBER, node)}>
                  <EncryptedDataBox
                    label={t("Account number")}
                    value={accountNumber}
                    disabled={false}
                    required={true}
                    forceValidate={props.forceValidate || accountNumberAutoGenerated}
                    validator={(value) => isEmpty(value) ? getI18Text("is required field", { label: bankCountry?.path === 'SE' ? "Bankgiro" : t("Account number") }) : ''}
                    onChange={value => { setAccountNumber(value); setAccountNumberAutoGenerated(false); handleFieldValueChange(ACCOUNT_NUMBER, accountNumber, value) }}
                  />
                </div>
              </Grid>
              <Grid item md={COL1} xs={0}></Grid>
            </>
            : <>
              <Grid item md={COL3} xs={COL4}>
                <div data-testid="account-number-field" ref={(node) => storeRef(ACCOUNT_NUMBER, node)}>
                  <EncryptedDataBox
                    label={t("Account number")}
                    value={accountNumber}
                    disabled={false}
                    required={true}
                    forceValidate={props.forceValidate || accountNumberAutoGenerated}
                    validator={(value) => isEmpty(value) ? getI18Text("is required field", { label: bankCountry?.path === 'SE' ? "Bankgiro" : t("Account number") }) : ''}
                    onChange={value => { setAccountNumber(value); setAccountNumberAutoGenerated(false); handleFieldValueChange(ACCOUNT_NUMBER, accountNumber, value) }}
                  />
                </div>
              </Grid>
              <Grid item md={COL1} xs={0}></Grid>
            </>}
        </>}
    </>)
  }

  function getPaymentAddressComponent() {
    return (<>
      {applicableFields[PAYMENT_ADDRESS] && (!props.existing || !existingData[PAYMENT_ADDRESS]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="payment-address-field" ref={(node) => storeRef(PAYMENT_ADDRESS, node)}>
            <EncryptedDataBox
              label={"Bankgiro"} // Use country specific names
              value={paymentAddress}
              disabled={false}
              required={true}
              forceValidate={props.forceValidate}
              validator={(value) => isEmpty(value) ? getI18Text("is required field", { label: "Bankgiro" }) : ''}
              onChange={value => { setPaymentAddress(value); handleFieldValueChange(PAYMENT_ADDRESS, paymentAddress, value) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
      </>}
    </>)
  }

  function getIsIbanAvailableComponent() {
    return (<>
      {applicableFields[IS_IBAN_AVAILABLE] && (!props.existing || !existingData[IS_IBAN_AVAILABLE]) &&
        <Grid item md={COL4} xs={COL4}>
          <div data-testid="is-iban-available-field" ref={(node) => storeRef(IS_IBAN_AVAILABLE, node)}>
            <Radio
              name='is-iban-available'
              id='is-iban-available'
              label={t("--doYouWishToProvideIban--")}
              value={isIbanAvailable !== undefined ? mapStringToOption(isIbanAvailable.toString()) : undefined}
              options={IS_IBAN_AVAILABLE_OPTIONS}
              forceValidate={props.forceValidate}
              required={true}
              showHorizontal={true}
              validator={(value) => isEmpty(value) ? getI18Text("is required field", { label: 'This' }) : ''}
              onChange={value => setIsIbanAvailable(value?.path ? (value.path === 'true') : undefined)}
            />
          </div>
        </Grid>}
    </>)
  }

  function getBankCodeComponent() {
    return (<>
      {/* For existing, SHOW if none of bankCode or encryptedBankCode available */}
      {applicableFields[BANK_CODE] && (!props.existing || !existingData[BANK_CODE]) &&
        <>
          {(keyOptions.length > 1)
            ? <>
              <Grid item md={COL1} xs={COL4}>
                <TypeAhead
                  label={t("Bank code")}
                  value={keyOption}
                  options={keyOptions}
                  required={true}
                  forceValidate={props.forceValidate}
                  validator={(value) => (isEmpty(value)) ? getI18Text("is required field", { label: t("Bank code") }) : ''}
                  onChange={value => { setKeyOption(value); handleFieldValueChange(KEY, keyOption, value) }}
                />
              </Grid>
              <Grid item md={COL2} xs={COL4}>
                <div data-testid="bank-code-field" ref={(node) => storeRef(BANK_CODE, node)}>
                  <label className={styles.label}>
                    {props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code")}
                    {props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.description &&
                      <Tooltip title={props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.description}>
                        <Info size={16} cursor="pointer" color="var(--warm-neutral-shade-300)" />
                      </Tooltip>}
                  </label>
                  {!bankCodeEncrypted &&
                    <TextBox
                      value={bankCode}
                      disabled={false}
                      required={true}
                      forceValidate={forceValidate || props.forceValidate || bankCodeAutoGenerated}
                      validator={(value) => bankCodeError
                        ? getI18Text("is invalid", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") })
                        : (isEmpty(value) ? getI18Text("is required field", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") }) : '')}
                      onChange={value => { setBankCode(value); handleFieldValueChange(BANK_CODE, bankCode, value, true); setBankCodeAutoGenerated(false) }}
                    />}
                  {bankCodeEncrypted &&
                    <EncryptedDataBox
                      value={encryptedBankCode}
                      disabled={false}
                      required={true}
                      forceValidate={forceValidate || props.forceValidate || bankCodeAutoGenerated}
                      validator={(value) => bankCodeError
                        ? getI18Text("is invalid", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") })
                        : (isEmpty(value) ? getI18Text("is required field", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") }) : '')}
                      onChange={value => { setEncryptedBankCode(value); handleFieldValueChange(ENCRYPTED_BANK_CODE, encryptedBankCode, value, true); setBankCodeAutoGenerated(false) }}
                    />}
                </div>
              </Grid>
              <Grid item md={COL1} xs={0}></Grid>
            </>
            : <>
              <Grid item md={COL3} xs={COL4}>
                <div data-testid="bank-code-field" ref={(node) => storeRef(BANK_CODE, node)}>
                  <label className={styles.label}>
                    {props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code")}
                    {props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.description &&
                      <Tooltip title={props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.description}>
                        <Info size={16} cursor="pointer" color="var(--warm-neutral-shade-300)" />
                      </Tooltip>}
                  </label>
                  {!bankCodeEncrypted &&
                    <TextBox
                      value={bankCode}
                      disabled={false}
                      required={true}
                      forceValidate={forceValidate || props.forceValidate}
                      validator={(value) => bankCodeError
                        ? getI18Text("is invalid", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") })
                        : (isEmpty(value) ? getI18Text("is required field", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") }) : '')}
                      onChange={value => { setBankCode(value); handleFieldValueChange(BANK_CODE, bankCode, value, true) }}
                    />}
                  {bankCodeEncrypted &&
                    <EncryptedDataBox
                      value={encryptedBankCode}
                      disabled={false}
                      required={true}
                      forceValidate={forceValidate || props.forceValidate}
                      validator={(value) => bankCodeError
                        ? getI18Text("is invalid", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") })
                        : (isEmpty(value) ? getI18Text("is required field", { label: props.bankKeys?.find(enumVal => enumVal.code === keyOption?.path)?.name || keyOption?.path || t("Bank code") }) : '')}
                      onChange={value => { setEncryptedBankCode(value); handleFieldValueChange(ENCRYPTED_BANK_CODE, encryptedBankCode, value, true) }}
                    />}
                </div>
              </Grid>
              <Grid item md={COL1} xs={0}></Grid>
            </>}
        </>}
    </>)
  }

  function getInternationalCodeComponent() {
    return (<>
      {/* For existing, SHOW if none of internationalCode or encryptedInternationalBankCode available */}
      {applicableFields[INTERNATIONAL_CODE] && (!props.existing || !existingData[INTERNATIONAL_CODE]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="int-bank-code-field" ref={(node) => storeRef(INTERNATIONAL_CODE, node)}>
            <label className={styles.label}>
              {(props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.name || 'IBAN')}
              {props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.description &&
                <Tooltip title={props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.description} >
                  <Info size={16} cursor="pointer" color="var(--warm-neutral-shade-300)" />
                </Tooltip>}
            </label>
            {!internationalCodeEncrypted &&
              <TextBox
                value={internationalCode}
                disabled={false}
                required={true}
                forceValidate={forceValidate || props.forceValidate}
                validator={(value) => internationalCodeError
                  ? getI18Text("is invalid", { label: (props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.name || 'IBAN') })
                  : (isEmpty(value)) ? getI18Text("is required field", { label: props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.name || 'IBAN' }) : ''}
                onChange={value => { setInternationalCode(value); handleFieldValueChange(INTERNATIONAL_CODE, internationalCode, value, true) }}
              />}
            {internationalCodeEncrypted &&
              <EncryptedDataBox
                value={encryptedInternationalBankCode}
                disabled={false}
                required={true}
                forceValidate={forceValidate || props.forceValidate}
                validator={(value) => internationalCodeError
                  ? getI18Text("is invalid", { label: props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.name || 'IBAN' })
                  : (isEmpty(value) ? getI18Text("is required field", { label: props.bankKeys?.find(enumVal => enumVal.code === 'iban')?.name || 'IBAN' }) : '')}
                onChange={value => { setEncryptedInternationalBankCode(value); handleFieldValueChange(ENCRYPTED_INTERNATIONAL_CODE, encryptedInternationalBankCode, value, true) }}
              />}
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getSwiftCodeComponent() {
    return (<>
      {/* For existing, SHOW if swiftCode not available */}
      {applicableFields[SWIFT_CODE] && (!props.existing || !existingData[SWIFT_CODE]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="swift-code-field" ref={(node) => storeRef(SWIFT_CODE, node)}>
            <TextBox
              label={props.bankKeys?.find(enumVal => enumVal.code === 'swift')?.name || 'SWIFT'}
              value={swiftCode}
              required={!canRespectSwiftCodeConfig({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) || isFieldRequired(fieldMap, SWIFT_CODE)}
              forceValidate={forceValidate || props.forceValidate || swiftCodeAutoGenerated}
              validator={(value) => (canRespectSwiftCodeConfig({ paymentModes, bankInformation: { bankAddress, isIbanAvailable }, bankKeys }) && !isFieldRequired(fieldMap, SWIFT_CODE))
                ? ''
                : (swiftCodeError
                  ? getI18Text("is invalid", { label: 'SWIFT' })
                  : isEmpty(value) ? getI18Text("is required field", { label: 'SWIFT' }) : '')}
              onChange={value => { setSwiftCode(value); setSwiftCodeAutoGenerated(false); handleFieldValueChange(SWIFT_CODE, swiftCode, value, true) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getCheckAddressComponent() {
    return (<>
      {/* For existing, SHOW if checkDeliveryAddress not available */}
      {applicableFields[CHECK_DELIVERY_ADDRESS] && (!props.existing || !existingData[CHECK_DELIVERY_ADDRESS]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="check-delivery-address-field" ref={(node) => storeRef(CHECK_DELIVERY_ADDRESS, node)}>
            <GoogleMultilinePlaceSearch
              id={`${CHECK_DELIVERY_ADDRESS}-${props.index}`}
              label={t("--checkDeliveryAddress--")}
              value={checkDeliveryAddress}
              countryOptions={props.countryOptions}
              required={true}
              forceValidate={props.forceValidate}
              validator={validateCheckAddress}
              onChange={(value, countryChanged) => { setCheckDeliveryAddress(value); handleFieldValueChange(CHECK_DELIVERY_ADDRESS, checkDeliveryAddress, value) }}
              parseAddressToFill={(place) => onPlaceSelectParseAddress(place)}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getDocumentComponent() {
    return (<>
      {/* For existing, SHOW if attachment not available */}
      {/* {applicableFields['separator2'] && (!props.existing || !existingData['separator2']) && <>
        <Grid item xs={COL4}>
          <div className={v4Styles.title}>
            {t("--bankDoucumentForValidation--")}
          </div>
        </Grid>
      </>} */}

      {/* For existing, SHOW if documentType not available */}
      {applicableFields[DOCUMENT_TYPE] && (!props.existing || !existingData[DOCUMENT_TYPE]) &&
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="ducument-type-field" ref={(node) => storeRef(DOCUMENT_TYPE, node)}>
            <TypeAhead
              label={t("--selectProofOfDucumentForBank--")}
              value={documentType}
              options={documentTypeOptions}
              disabled={false}
              required={isFieldRequired(fieldMap, BANK_DOUCUMENT)}
              forceValidate={props.forceValidate}
              validator={(value) => (isFieldRequired(fieldMap, BANK_DOUCUMENT) && isEmpty(value)) ? getI18Text("is required field", { label: t("--documentType--") }) : ''}
              onChange={value => { setDocumentType(value); handleFieldValueChange(DOCUMENT_TYPE, documentType, value) }}
            />
          </div>
        </Grid>}

      {/* For existing, SHOW if attachment not available */}
      {applicableFields[ATTACHMENT] && (!props.existing || !existingData[ATTACHMENT]) && <>
        <Grid item md={COL4} xs={COL4}>
          <div data-testid="attachment-field" ref={(node) => storeRef(ATTACHMENT, node)}>
            <AttachmentControlNew
              value={attachment}
              config={{
                fieldName: ATTACHMENT,
                optional: !isFieldRequired(fieldMap, BANK_DOUCUMENT),
                fileTypes: [pdfFileAcceptType, imageFileAcceptType],
                forceValidate: props.forceValidate,
              }}
              dataFetchers={{
                getDocumentByName: loadFile
              }}
              validator={(value) => (isFieldRequired(fieldMap, BANK_DOUCUMENT) && isEmpty(value)) ? getI18Text("is required field", { label: t("--attachment--") }) : ''}
              onChange={(value, file, fieldname) => { setAttachment(file); handleFieldValueChange(fieldname, attachment, file as File, false, true) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getIntermediaryCodeComponent() {
    return (<>
      {/* For existing, SHOW if intermediaryBankCode not available */}
      {applicableFields[INTREMEDIARY_REQUIRED] && (!props.existing || !existingData[INTREMEDIARY_REQUIRED]) &&
        <Grid item xs={COL4}>
          <div data-testid="intermediary-required-field" ref={(node) => storeRef(INTREMEDIARY_REQUIRED, node)}>
            <ToggleSwitch
              label={t("FFC banking info")}
              value={intermediaryBankRequired}
              falsyLabel={getI18Text("No")}
              truthyLabel={getI18Text("Yes")}
              onChange={(value) => { setIntermediaryBankRequired(value); handleFieldValueChange(INTREMEDIARY_REQUIRED, intermediaryBankRequired, value) }}
            />
          </div>
        </Grid>}

      {applicableFields[INTREMEDIARY_NAME] && (!props.existing || !existingData[INTREMEDIARY_NAME]) &&
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="intermediary-bank-name-field" ref={(node) => storeRef(INTREMEDIARY_NAME, node)}>
            <TextBox
              label={t("Intermediary bank name")}
              value={intermediaryBankName}
              disabled={false}
              required={true}
              forceValidate={props.forceValidate}
              validator={(value) => isEmpty(value) ? getI18Text("is required field", { label: t("Intermediary bank name") }) : ''}
              onChange={value => { setIntermediaryBankName(value); handleFieldValueChange(INTREMEDIARY_NAME, intermediaryBankName, value) }}
            />
          </div>
        </Grid>}

      {applicableFields[INTREMEDIARY_ADDRESS] && (!props.existing || !existingData[INTREMEDIARY_ADDRESS]) &&
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="intermediary-bank-address-field" ref={(node) => storeRef(INTREMEDIARY_ADDRESS, node)}>
            <GoogleMultilinePlaceSearch
              id={`${INTREMEDIARY_ADDRESS}-${props.index}`}
              label={t("Intermediary bank address")}
              value={intermediaryBankAddress}
              countryOptions={props.countryOptions}
              forceValidate={props.forceValidate}
              onChange={(value, countryChanged) => { setIntermediaryBankAddress(value); countryChanged && handleFieldValueChange(INTREMEDIARY_ADDRESS, intermediaryBankAddress, value) }}
              parseAddressToFill={(place) => onPlaceSelectParseAddress(place)}
            />
          </div>
        </Grid>}

      {applicableFields[INTREMEDIARY_CODE] && (!props.existing || !existingData[INTREMEDIARY_CODE]) && <>
        <Grid item md={COL3} xs={COL4}>
          <div data-testid="intermediary-bank-code-field" ref={(node) => storeRef(INTREMEDIARY_CODE, node)}>
            <TextBox
              label={props.bankKeys?.find(enumVal => enumVal.code === intermediaryKey)?.name || intermediaryKey || t("Intermediary bank code")}
              value={intermediaryBankCode}
              disabled={false}
              required={true}
              forceValidate={forceValidate || props.forceValidate}
              validator={(value) => intermediaryCodeError ?
                getI18Text("is invalid", { label: t("Intermediary bank code") }) : isEmpty(value) ? getI18Text("is required field", { label: t("Intermediary bank code") }) : ''}
              onChange={value => { setIntermediaryBankCode(value); handleFieldValueChange(INTREMEDIARY_CODE, intermediaryBankCode, value, true) }}
            />
          </div>
        </Grid>
        <Grid item md={COL1} xs={0}></Grid>
        </>}
    </>)
  }

  function getAccountSectionSeparator() {
    return (<>
      {applicableFields['separator1'] && (!props.existing || !existingData['separator1']) && <>
        <Grid item xs={COL4}>
          <div className={styles.title}>
            {t("Account details")}
          </div>
        </Grid>
      </>}
    </>)
  }

  function getNoDetailsNeededComponent() {
    return (<>
      {applicableFields[NO_DETAILS_NEEDED] && <>
        <Grid item xs={COL4}>
          <div className={styles.noDetailsNeeded}>
            <AlertCircle color='var(--warm-neutral-shade-200)' size={18} />
            {t('--directDebitDoesNotRequireAnyAccountDetails--')}
          </div>
        </Grid>
      </>}
    </>)
  }

  const fieldComponentMap = {
    [PAYMENT_MODES]: getPaymentModeComponent,
    [IS_IBAN_AVAILABLE]: getIsIbanAvailableComponent,
    [BANK_NAME]: getBankNameComponent,
    [ACCOUNT_HOLDER]: getAccHolderComponent,
    [ACCOUNT_HOLDER_ADDR]: getAccHolderAddressComponent,
    [ACCOUNT_NUMBER]: getAccNumberComponent,
    [PAYMENT_ADDRESS]: getPaymentAddressComponent,
    [BANK_CODE]: getBankCodeComponent,
    [INTERNATIONAL_CODE]: getInternationalCodeComponent,
    [SWIFT_CODE]: getSwiftCodeComponent,
    [CHECK_DELIVERY_ADDRESS]: getCheckAddressComponent,
    [ATTACHMENT]: getDocumentComponent,
    [INTREMEDIARY_CODE]: getIntermediaryCodeComponent,
    [NO_DETAILS_NEEDED]: getNoDetailsNeededComponent
  }
  const fieldOrder = [
    PAYMENT_MODES,
    PAYMENT_ADDRESS, IS_IBAN_AVAILABLE, INTERNATIONAL_CODE, BANK_CODE,
    ACCOUNT_NUMBER, ACCOUNT_HOLDER, ACCOUNT_HOLDER_ADDR, BANK_NAME,
    SWIFT_CODE, CHECK_DELIVERY_ADDRESS,
    ATTACHMENT, INTREMEDIARY_CODE,
    NO_DETAILS_NEEDED
  ]

  function getPaymentModeLogo (): string {
    const currentModeOption = PaymentModeOptions.find(option => option.code === paymentModes[0]?.type)
    return currentModeOption?.logo
  }

  function onEdit () {
    // setExpanded(true)
    props.onEdit()
  }

  return (
    <Grid container spacing={2.5} pb={2} pr={2} className={styles.paymentOption} >
      <Grid item xs={COL4}>
        <div className={`${v4Styles.title} ${props.existing ? v4Styles.existing : ''}`}>
          {props.existing && props.canExtend &&
            <div className={classnames(v4Styles.selectButton, { [v4Styles.selected]: selected })} onClick={toggleSelection}>
              {selected && <Check size={12} strokeWidth={'3px'} color='var(--warm-prime-chalk)' />}
            </div>}
          <span className={v4Styles.modeWrapper}>
            <div className={v4Styles.logo}>
              <img src={getPaymentModeLogo()} />
            </div>
            <span>{PaymentModeOptions.find(option => option.code === paymentModes[0]?.type)?.displayName}</span>
          </span>
          <div className={styles.spread} />
          {!props.existing && <OroButton type='link' label={t('--edit--')} icon={<Edit3 size={14} />} iconOrientation='left' onClick={onEdit} />}
          {!props.existing && <Trash size={18} color={'var(--warm-neutral-shade-300)'} cursor="pointer" onClick={handleDeleteClick} />}
        </div>

        <div className={`${styles.card} ${v4Styles.card} ${(props.existing && props.canExtend) ? v4Styles.existing : ''}`}>
          <div className={v4Styles.primaryInfo}>
            {(cardIBAN || cardAccountNumber) && cardBankName && <span>{cardBankName}</span>}
            {(cardIBAN || cardAccountNumber || cardPaymentAddress) && <span className={v4Styles.secondaryInfo}>{cardBankName && ' '}({cardIBAN || cardAccountNumber || cardPaymentAddress})</span>}
            {cardDirectDebitMsg}
          </div>

          {!props.existing &&
            <OroButton
              type='link'
              label={expanded ? t('--hideDetails--') : t('--viewAllDetails--')}
              icon={expanded ? <ChevronUp size={16}/> : <ChevronDown size={16}/>}
              iconOrientation='right'
              className={v4Styles.expandBtn}
              onClick={() => setExpanded(!expanded)}
            />}
        </div>

        {expanded && <>
          <Grid item xs={COL4}>
            <Separator />
          </Grid>
          <PaymentDetailBox
            title={props.title}
            index={props.index}
            last={props.last}
            hideCompanyEntitySelector={true}
            data={props.data}
            fields={props.fields}
            countryOptions={props.countryOptions}
            trackedAttributes={props.trackedAttributes}
            bankKeys={props.bankKeys}
            getCountryBankKeys={props.getCountryBankKeys}
            loadDocument={props.loadDocument}
          />
        </>}
      </Grid>

      {(props.existing && selected) && <>
        {fieldOrder.map((field, i) => <Fragment key={i}>{fieldComponentMap[field]()}</Fragment>)}
      </>}
    </Grid>
  )
}
